#include <stdio.h>

int main() {

//값의 의미() 및 메모리 할당 크기
//~~~~~
// |
// V
//(1) 타입 (2) 변수 <- (3) 값 
//                 ~~~~~~
//                  저장

    //unsigned char a = 'A';
    unsigned char a = 0x41;
    printf("a is 0x%2X, 'd'%d, 'c'%c, %d byte allocated on mon\n", a, a, a, sizeof(a));


// HUMAN d1 = 나를 디지털화한 0과 1로 이루어진 집합
// sizeof(human) --> 1조 바이트
// 주소 01035481456-> 주소가 아주 효율적임
//(4)주소..란...-> 어떤 변수(메모리의 한 영역)울 가르킬 수 있는 포인터이다.

printf("a's adress is 0x%p allocated on memory\n", &a);
 
//주소도 값의 일종이다. 따라서 변수에 쓸 수 있다.(담을 수 있다)
//p = 0x000000000061FE1F;
//값은 값인데 특수한 값 -> 주소값
// 따라서, 값을 담을 변수에 타입을 주어야 한다. 주소값을 담을 수 있도록 
// 변수의 타입은 담을 수 있는 값의 종류를 제한한다
// 타입 선언부에 *를 쓰면, 담을 수 있는 값의 종류로 주소만 담을 수 있도록 제한한다.
// * p = 0x000000000061FE1F

//그런데, 그 주소가 가리키는 대상이 무엇인가? 여기서는 unsigned char를 가리킴 
// unsigned char* p = 0x000000000061FE1F;
// 그래서 p 라는 변수는 값을 담고 있는데, 주소를 담고 있고, 
//주소는 메모리의 특정 영역을 가리키고 있다. 어떤 위치를 가리키는 포인터이다!
//따라서 우리는 이제, 어떤 영역을 가리킬 수 있는 변수를 포인터변수라고 지칭하자.
//a라는 변수는 메모리의 한 공간이고, 값을 가질 수 있고 (서울역 사물함 100번 열어본, 0x41이 있음)

//그런데, p라는 변수 역시 메모리의 한 공간이다. 따라서 값을 가질 ㅜ수 있다.
//그러나  열어보니 하필 다른곳을 가리키는 주소값(포인터)를 보고있따.
// (사물함 열어보니 종이쪼가리 하나 적혀있고 45라적혀있음)ㄴ

//아래 일반 상수값이 주소라는 것을 정확하게 표현
unsigned char* p = (unsigned char*)0x000000000061FE17;
//                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                  = &a; 로 대체 가능
// unsigned char* p = &a;

//human k1 =
//human* kp = &k1 - kp에는 주소가 담겨져 있음
//human* kp = (human*)01035481456;
//드디어 주소 또는 포인터를 이용해서 전화를 걸어보자
// 포인터 변수 앞에 *를 붙이면, 그 주소가 가리키는 영역에 접근하게 된다.
// *kp = "사랑해" -> 주소 기반으로 접근해서 쓰기
//  X = *kp -> 주소를 이용해서 접근해서 읽기


//주소를 이용해서 변수 a에 접근해 보자. 전화걸기 -> 포인터 앞에 *붙이기
printf("a is 0x%2X\n", *p);

//주소를 이용해서 전화걸고 값 쓰기
*p = 0x5A;
printf("a is 0x%2X\n", *p);

printf("we can access var 'a' 0x%2X using p's address 0x%p\n", *p, p);
printf("so, p's address is %p\n", &p);



//p = (unsigned char*)(0x000000000061FE1F);


//모든 포인터들의 원리
//p라는 변수의 주소는 &p (또는 물리적으로 0x00000000xxxxx)
//포인터 변수 조차도 변수이므로, 메모리에 할당 될 것이고, 주소가 있을 것임
//따라서 포인터(주소를 담은)변수도 메모리의 특정 주소에 할당되어 있고,
//따라서 그 주소 조차도 다른 변수에 저장할 수 있다.
//                     = &p;
//                  pp = &p;  //주소를 담을 변수 pp
//                * pp = &p;  //값 중에서 구체적으로 주소값을 담을 수 있게
//(unsighed char*)* pp = &p; 그 주소가 가르키는 실체는, unsigned char*임
//unsighed char **  pp = &p 이중 포인터

unsigned char**  pp = &p;

//*가 붙어있으면 주소임

printf("p's address is 0x%p\n", &p); // p의 주소
printf("pp's value is 0x%p\n", pp); // pp값 = p의 주소
printf("a's address is 0x%p\n", *pp); // a의 주소 (pp의 값(주소형식) *-> 주소로 이동(p의 값,주소형식))
printf("a's value is 0x%2X\n", **pp); // a의 값 (pp의 값(주소 형식) *-> 주소로 이동(p의 값,주소형식) *-> 주소로 이동(a의 값))
//printf("we can access var 'a' 0x%2X using p's address 0x%p\n", *p, p);


    return 0;

}